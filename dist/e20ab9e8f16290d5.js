import*as THREE from"three";import{scene,camera,renderer}from"./basics";import{OrbitControls}from"three/examples/jsm/controls/OrbitControls";import{GUI}from"dat.gui";const controls=new OrbitControls(camera,renderer.domElement),gui=new GUI,boxPos=gui.addFolder("box position"),helper=new THREE.AxesHelper(10);helper.setColors("blue","yellow","green"),scene.add(helper);const vertices=[{pos:[-1,-1,1],norm:[0,0,1],uv:[0,0]},{pos:[1,-1,1],norm:[0,0,1],uv:[1,0]},{pos:[-1,1,1],norm:[0,0,1],uv:[0,1]},{pos:[1,1,1],norm:[0,0,1],uv:[1,1]},{pos:[1,-1,1],norm:[1,0,0],uv:[0,0]},{pos:[1,-1,-1],norm:[1,0,0],uv:[1,0]},{pos:[1,1,1],norm:[1,0,0],uv:[0,1]},{pos:[1,1,-1],norm:[1,0,0],uv:[1,1]},{pos:[1,-1,-1],norm:[0,0,-1],uv:[0,0]},{pos:[-1,-1,-1],norm:[0,0,-1],uv:[1,0]},{pos:[1,1,-1],norm:[0,0,-1],uv:[0,1]},{pos:[-1,1,-1],norm:[0,0,-1],uv:[1,1]},{pos:[-1,-1,-1],norm:[-1,0,0],uv:[0,0]},{pos:[-1,-1,1],norm:[-1,0,0],uv:[1,0]},{pos:[-1,1,-1],norm:[-1,0,0],uv:[0,1]},{pos:[-1,1,1],norm:[-1,0,0],uv:[1,1]},{pos:[1,1,-1],norm:[0,1,0],uv:[0,0]},{pos:[-1,1,-1],norm:[0,1,0],uv:[1,0]},{pos:[1,1,1],norm:[0,1,0],uv:[0,1]},{pos:[-1,1,1],norm:[0,1,0],uv:[1,1]},{pos:[1,-1,1],norm:[0,-1,0],uv:[0,0]},{pos:[-1,-1,1],norm:[0,-1,0],uv:[1,0]},{pos:[1,-1,-1],norm:[0,-1,0],uv:[0,1]},{pos:[-1,-1,-1],norm:[0,-1,0],uv:[1,1]}];let posArr=new Float32Array(3*vertices.length),normArr=new Float32Array(3*vertices.length),uvArr=new Float32Array(2*vertices.length);const posNumComponents=3,normalNumComponents=3,uvNumComponents=2;let posNdx=0,normNdx=0,uvNdx=0;for(const e of vertices)posArr.set(e.pos,posNdx),normArr.set(e.norm,normNdx),uvArr.set(e.uv,uvNdx),posNdx+=3,normNdx+=3,uvNdx+=2;const newIndexes=[0,1,2,2,1,3,4,5,6,6,5,7,8,9,10,10,9,11,12,13,14,14,13,15,16,17,18,18,17,19,20,21,22,22,21,23],bufferGeom=new THREE.BufferGeometry;bufferGeom.setIndex(newIndexes);const posAttribute=new THREE.BufferAttribute(posArr,3),normalAttribute=new THREE.BufferAttribute(normArr,3),uvAttribute=new THREE.BufferAttribute(uvArr,2);bufferGeom.setAttribute("position",posAttribute),bufferGeom.setAttribute("normal",normalAttribute),bufferGeom.setAttribute("uv",uvAttribute);const material=new THREE.MeshBasicMaterial,cube=new THREE.Mesh(bufferGeom,material),cube2=cube.clone(),cube3=cube.clone();cube.position.set(-5,0,0),cube2.position.set(0,0,0),cube3.position.set(5,0,0);const array32Ex=new Float32Array(9);function makeSpherePositions(e,r,o){const t=new Float32Array(e*r*6*3),s=[],n=new THREE.Object3D,u=new THREE.Object3D,i=new THREE.Object3D;n.add(u),u.add(i),i.position.z=1;const m=new THREE.Vector3;function p(e,r){return u.rotation.x=e,n.rotation.y=r,n.updateMatrixWorld(!0),i.getWorldPosition(m).toArray()}let a=0,l=0;for(let o=0;o<r;++o){const n=(o+1)/r,u=(o/r-.5)*Math.PI,i=(n-.5)*Math.PI;for(let r=0;r<e;++r){const o=(r+1)/e,n=r/e*Math.PI*2,m=o*Math.PI*2;t.set(p(u,n),a),a+=3,t.set(p(i,n),a),a+=3,t.set(p(u,m),a),a+=3,t.set(p(i,m),a),a+=3,s.push(l,l+1,l+2,l+2,l+1,l+3),l+=4}}return{positions:t,indexes:s}}array32Ex.set([1,2,3],0),array32Ex.set([4,5,6],3),array32Ex.set([6,7,8],6);const positions=makeSpherePositions(36,36).positions,indexes=makeSpherePositions(36,36).indexes,sphereBufferGeometry=new THREE.BufferGeometry,segmentsAround=36,sphereAttributePoses=new THREE.BufferAttribute(positions,3),normals=positions.slice(),colors=positions.slice(),sphereAttributeColors=new THREE.BufferAttribute(colors,3);sphereBufferGeometry.setAttribute("position",sphereAttributePoses),sphereBufferGeometry.setAttribute("normal",new THREE.BufferAttribute(normals,3)),sphereAttributePoses.setUsage(THREE.DynamicDrawUsage),sphereBufferGeometry.setAttribute("color",sphereAttributeColors),sphereBufferGeometry.setIndex(indexes),material.vertexColors=!0;const sphere=new THREE.Mesh(sphereBufferGeometry,material);function render(e){e*=.001;const r=new THREE.Vector3;for(let o=0;o<positions.length;o+=3){const t=o/12|0,s=t/36|0,n=t%36/36*Math.PI;r.fromArray(normals,o),r.multiplyScalar(THREE.MathUtils.lerp(1,1.4,.5*Math.sin(e+s+n)+.5)),r.toArray(positions,o)}sphereAttributePoses.needsUpdate=!0,sphereAttributeColors.needsUpdate=!0,controls.update(),window.requestAnimationFrame(render),renderer.render(scene,camera)}scene.add(sphere),render();